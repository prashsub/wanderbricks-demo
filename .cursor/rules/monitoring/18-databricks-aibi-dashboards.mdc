---
description: Best practices for creating Databricks Lakeview AI/BI dashboards with proper system table usage and layout formatting
globs: 
  - "**/*dashboard*.json"
  - "**/*.lvdash.json"
alwaysApply: false
---

# Databricks AI/BI Lakeview Dashboard Best Practices

## Critical: Grid System

**ALWAYS use a 6-column grid layout**, not 12-column!

### Widget Positioning Rules
```json
{
  "position": {
    "x": 0,     // Column position: 0-5 (6-column grid)
    "y": 0,     // Row position: any positive integer
    "width": 3,  // Width in columns: 1, 2, 3, 4, or 6 (must sum to ≤6 per row)
    "height": 6  // Height in units: common values are 1, 2, 6, 9
  }
}
```

### Grid Layout Examples
```json
// Two widgets side-by-side (each 3 columns wide)
{"x": 0, "y": 0, "width": 3, "height": 6}  // Left
{"x": 3, "y": 0, "width": 3, "height": 6}  // Right

// Three widgets across (each 2 columns wide)
{"x": 0, "y": 0, "width": 2, "height": 6}  // Left
{"x": 2, "y": 0, "width": 2, "height": 6}  // Center
{"x": 4, "y": 0, "width": 2, "height": 6}  // Right

// KPI counters (1 column each, 6 across)
{"x": 0, "y": 0, "width": 1, "height": 2}
{"x": 1, "y": 0, "width": 1, "height": 2}
{"x": 2, "y": 0, "width": 1, "height": 2}
{"x": 3, "y": 0, "width": 1, "height": 2}
{"x": 4, "y": 0, "width": 1, "height": 2}
{"x": 5, "y": 0, "width": 1, "height": 2}

// Full-width chart
{"x": 0, "y": 0, "width": 6, "height": 6}
```

### Common Height Values
- **Filters**: `height: 1` or `height: 2`
- **KPI Counters**: `height: 2`
- **Charts**: `height: 6` (standard), `height: 9` (large)
- **Tables**: `height: 6` or more

---

## System Tables: Schema Verification

**ALWAYS verify field names against official Databricks documentation** before using system tables.

### Critical System Tables Reference

#### 1. `system.lakeflow.jobs` (SCD2 Table)
```sql
-- CORRECT: Jobs table columns
SELECT 
  workspace_id,    -- STRING
  job_id,         -- STRING
  name,           -- STRING ⚠️ NOT job_name!
  description,    -- STRING
  creator_id,     -- STRING
  tags,           -- MAP
  change_time,    -- TIMESTAMP
  delete_time,    -- TIMESTAMP
  run_as          -- STRING (owner/service principal)
FROM system.lakeflow.jobs
```

**Pattern: Get Latest Job (SCD2 handling)**
```sql
WITH latest_jobs AS (
  SELECT workspace_id, job_id, name, run_as,
    ROW_NUMBER() OVER(PARTITION BY workspace_id, job_id 
                      ORDER BY change_time DESC) as rn
  FROM system.lakeflow.jobs
  WHERE delete_time IS NULL
  QUALIFY rn = 1
)
SELECT * FROM latest_jobs
```

#### 2. `system.lakeflow.job_task_run_timeline`
```sql
-- CORRECT: Task timeline columns
SELECT
  workspace_id,      -- STRING
  job_id,           -- STRING (NO job_name column!)
  run_id,           -- STRING
  task_key,         -- STRING
  period_start_time,-- TIMESTAMP
  period_end_time,  -- TIMESTAMP
  compute_ids,      -- ARRAY<STRING>
  result_state,     -- STRING
  termination_code  -- STRING
FROM system.lakeflow.job_task_run_timeline
```

**❌ WRONG: Assuming job_name exists**
```sql
-- This will FAIL!
SELECT job_name 
FROM system.lakeflow.job_task_run_timeline
```

**✅ CORRECT: JOIN with jobs table**
```sql
WITH latest_jobs AS (
  SELECT workspace_id, job_id, name,
    ROW_NUMBER() OVER(PARTITION BY workspace_id, job_id 
                      ORDER BY change_time DESC) as rn
  FROM system.lakeflow.jobs
  WHERE delete_time IS NULL
  QUALIFY rn = 1
)
SELECT 
  jtr.*,
  COALESCE(lj.name, 'Job ' || CAST(jtr.job_id AS STRING)) AS job_name
FROM system.lakeflow.job_task_run_timeline jtr
LEFT JOIN latest_jobs lj 
  ON jtr.workspace_id = lj.workspace_id 
  AND jtr.job_id = lj.job_id
```

#### 3. `system.compute.clusters`
```sql
-- Get latest DBR version per cluster
SELECT workspace_id, cluster_id, 
       MAX_BY(dbr_version, change_time) AS dbr_version
FROM system.compute.clusters
WHERE delete_time IS NULL
GROUP BY workspace_id, cluster_id
```

#### 4. `system.access.workspaces_latest`
```sql
-- Workspace filter data
SELECT 
  CAST(workspace_id AS STRING) AS workspace_id,
  COALESCE(workspace_name, CAST(workspace_id AS STRING)) AS workspace_name
FROM system.access.workspaces_latest
WHERE status = 'RUNNING'
```

#### 5. `system.information_schema.tables`
```sql
-- Table inventory
SELECT 
  table_catalog,
  table_schema,
  table_name,
  table_type,        -- 'EXTERNAL' or 'MANAGED'
  storage_path,
  data_source_format,
  last_altered
FROM system.information_schema.tables
WHERE table_type IN ('EXTERNAL', 'MANAGED')
```

---

## Widget Specifications

### KPI Counter (Version 2)
```json
{
  "name": "kpi_widget_name",
  "queries": [
    {
      "name": "main_query",
      "query": {
        "datasetName": "dataset_name",
        "fields": [
          {"name": "value", "expression": "`value`"}
        ],
        "disaggregated": false
      }
    }
  ],
  "spec": {
    "version": 2,
    "widgetType": "counter",
    "encodings": {
      "value": {
        "fieldName": "value"
      }
    },
    "frame": {
      "showTitle": true,
      "title": "KPI Title",
      "showDescription": true,
      "description": "Brief description"
    }
  }
}
```

**⚠️ Common Error**: Including `period` in encoding (not needed for version 2)

### Filter Widget (Single Select)
```json
{
  "name": "filter_name",
  "queries": [
    {
      "name": "main_query",
      "query": {
        "datasetName": "distinct_values_dataset",
        "fields": [
          {"name": "field_name", "expression": "`field_name`"}
        ],
        "disaggregated": false
      }
    }
  ],
  "spec": {
    "version": 2,
    "widgetType": "filter-single-select",
    "encodings": {
      "fields": [
        {
          "displayName": "Display Label",
          "fieldName": "field_name",
          "queryName": "main_query"
        }
      ]
    },
    "frame": {
      "showTitle": true,
      "title": "Filter Title"
    }
  }
}
```

### Bar Chart (Version 3)
```json
{
  "spec": {
    "version": 3,
    "widgetType": "bar",
    "encodings": {
      "x": {
        "fieldName": "category_field",
        "displayName": "X Axis Label",
        "scale": {"type": "categorical"}
      },
      "y": {
        "fieldName": "value_field",
        "displayName": "Y Axis Label",
        "scale": {"type": "quantitative"}
      },
      "color": {
        "fieldName": "group_field",
        "displayName": "Legend Label",
        "scale": {"type": "categorical"}
      }
    },
    "frame": {
      "showTitle": true,
      "title": "Chart Title",
      "showDescription": true,
      "description": "Chart description"
    }
  }
}
```

### Line Chart (Version 3)
```json
{
  "spec": {
    "version": 3,
    "widgetType": "line",
    "encodings": {
      "x": {
        "fieldName": "time_field",
        "displayName": "Time",
        "scale": {"type": "temporal"}
      },
      "y": {
        "fieldName": "value_field",
        "displayName": "Value",
        "scale": {"type": "quantitative"}
      },
      "color": {
        "fieldName": "series_field",
        "displayName": "Series",
        "legend": {"position": "right"}
      }
    }
  }
}
```

### Pie Chart (Version 3)
```json
{
  "spec": {
    "version": 3,
    "widgetType": "pie",
    "encodings": {
      "angle": {
        "fieldName": "value_field",
        "displayName": "Value",
        "scale": {"type": "quantitative"}
      },
      "color": {
        "fieldName": "category_field",
        "displayName": "Category",
        "scale": {"type": "categorical"}
      }
    }
  }
}
```

### Table Widget (Version 1)
```json
{
  "spec": {
    "version": 1,
    "widgetType": "table",
    "frame": {
      "showTitle": true,
      "title": "Table Title",
      "showDescription": true,
      "description": "Table description"
    },
    "encodings": {
      "columns": [
        {
          "fieldName": "field1",
          "title": "Column 1"
        },
        {
          "fieldName": "field2",
          "title": "Column 2",
          "useMonospaceFont": true
        },
        {
          "fieldName": "timestamp_field",
          "title": "Timestamp",
          "dateTimeFormat": "yyyy-MM-dd HH:mm",
          "type": "datetime",
          "displayAs": "datetime"
        }
      ]
    },
    "itemsPerPage": 50,
    "paginationSize": "default",
    "condensed": true,
    "withRowNumber": true
  }
}
```

---

## Date Parameters

**Use DATE type, not DATETIME**, with static date strings:

```json
{
  "displayName": "Start Date",
  "keyword": "start_date",
  "dataType": "DATE",
  "defaultSelection": {
    "values": {
      "dataType": "DATE",
      "values": [{"value": "2024-01-01"}]
    }
  }
}
```

**❌ WRONG**: Using DATETIME or dynamic expressions
```json
{"dataType": "DATETIME", "values": [{"value": "now-12M/M"}]}
```

---

## Global Filters Page

Always include a Global Filters page for cross-dashboard filtering:

```json
{
  "name": "page_global_filters",
  "displayName": "Global Filters",
  "pageType": "PAGE_TYPE_GLOBAL_FILTERS",
  "layout": [
    {
      "widget": {
        "name": "workspace_filter",
        "spec": {
          "version": 2,
          "widgetType": "filter-single-select",
          "frame": {
            "showTitle": true,
            "title": "Workspace"
          }
        }
      },
      "position": {"x": 0, "y": 0, "width": 2, "height": 2}
    }
  ]
}
```

---

## Query Best Practices

### Pattern: "All" Option for Filters
```sql
SELECT 'All' AS filter_value
UNION ALL
SELECT DISTINCT actual_value AS filter_value
FROM source_table
ORDER BY filter_value
```

### Pattern: Handle NULL/Missing Values
```sql
COALESCE(field_name, 'Unknown')
COALESCE(field_name, 'Field ' || CAST(id_field AS STRING))
```

### Pattern: Dynamic Filtering
```sql
WHERE ( :filter_param = 'All' OR field IN (:filter_param) )
```

### Pattern: Date Range Filtering
```sql
WHERE DATE(timestamp_field) >= :start_date 
  AND DATE(timestamp_field) <= :end_date
```

### Pattern: Extract Version Numbers
```sql
CAST(regexp_extract(version_string, '^(\\d+)', 1) AS INT)
```

---

## Theme & Colors

Use the Databricks standard color palette:

```json
{
  "uiSettings": {
    "theme": {
      "canvasBackgroundColor": {"light": "#F7F9FA", "dark": "#0B0E11"},
      "widgetBackgroundColor": {"light": "#FFFFFF", "dark": "#1A1D21"},
      "widgetBorderColor": {"light": "#E0E4E8", "dark": "#2A2E33"},
      "fontColor": {"light": "#11171C", "dark": "#E8ECF0"},
      "selectionColor": {"light": "#077A9D", "dark": "#8ACAE7"},
      "visualizationColors": [
        "#077A9D",  // Primary blue
        "#00A972",  // Green
        "#FFAB00",  // Amber
        "#FF3621",  // Red
        "#8BCAE7",  // Light blue
        "#99DDB4",  // Light green
        "#FCA4A1",  // Light red
        "#AB4057",  // Maroon
        "#6B4FBB",  // Purple
        "#BF7080"   // Rose
      ],
      "widgetHeaderAlignment": "LEFT"
    },
    "genieSpace": {"isEnabled": false}
  }
}
```

---

## Common Pitfalls

### ❌ AVOID: Assuming Field Names
Always verify against documentation. Common mistakes:
- `job_name` doesn't exist in `job_task_run_timeline` (use `name` from `jobs` table)
- Forgetting to handle SCD2 tables with `QUALIFY rn=1`
- Not filtering out deleted records with `WHERE delete_time IS NULL`

### ❌ AVOID: 12-Column Grid
**Use 6-column grid!** Widget widths must be 1-6, not 1-12.

### ❌ AVOID: Complex Y-Positioning
Keep Y positions sequential and use consistent heights (2, 6, 9).

### ❌ AVOID: Missing JOIN Conditions
Always JOIN on both `workspace_id` AND the entity ID (job_id, cluster_id, etc.).

---

## Verification Checklist

Before finalizing a dashboard:

- [ ] All widget positions use 6-column grid (widths: 1-6)
- [ ] All system table fields verified against [official docs](https://docs.databricks.com/aws/en/admin/system-tables/)
- [ ] SCD2 tables handled with `QUALIFY rn=1` pattern
- [ ] Deleted records filtered with `WHERE delete_time IS NULL`
- [ ] JOINs include both `workspace_id` and entity ID
- [ ] Date parameters use `DATE` type with static values
- [ ] KPIs use version 2 with simple `value` encoding
- [ ] Global Filters page included
- [ ] All filters have "All" option
- [ ] NULL values handled with COALESCE
- [ ] Theme colors match Databricks palette

---

## Documentation References

Always reference these URLs when working with system tables:

- **System Tables Overview**: https://docs.databricks.com/aws/en/admin/system-tables/
- **Jobs System Tables**: https://docs.databricks.com/aws/en/admin/system-tables/jobs
- **Compute System Tables**: https://docs.databricks.com/aws/en/admin/system-tables/compute
- **Access System Tables**: https://docs.databricks.com/aws/en/admin/system-tables/access

---

## Example: Complete Widget Definition

```json
{
  "widget": {
    "name": "chart_jobs_by_workspace",
    "queries": [
      {
        "name": "main_query",
        "query": {
          "datasetName": "jobs_by_workspace_dbr",
          "fields": [
            {"name": "workspace_name", "expression": "`workspace_name`"},
            {"name": "dbr_version", "expression": "`dbr_version`"},
            {"name": "job_count", "expression": "`job_count`"}
          ],
          "disaggregated": false
        }
      }
    ],
    "spec": {
      "version": 3,
      "widgetType": "bar",
      "encodings": {
        "x": {
          "fieldName": "workspace_name",
          "displayName": "Workspace",
          "scale": {"type": "categorical"}
        },
        "y": {
          "fieldName": "job_count",
          "displayName": "Job Count",
          "scale": {"type": "quantitative"}
        },
        "color": {
          "fieldName": "dbr_version",
          "displayName": "DBR Version",
          "scale": {"type": "categorical"}
        }
      },
      "frame": {
        "showTitle": true,
        "title": "Jobs by Workspace & DBR Version",
        "showDescription": true,
        "description": "Distribution of jobs across workspaces"
      }
    }
  },
  "position": {"x": 0, "y": 2, "width": 3, "height": 6}
}
```

---

## Pro Tips

1. **Start with a reference dashboard** - Use existing Databricks AI/BI dashboards as templates
2. **Test queries separately** - Run SQL in Databricks SQL editor before embedding
3. **Use descriptive names** - Dataset and widget names should be self-documenting
4. **Keep it modular** - One dataset per logical query, reuse via multiple widgets
5. **Add descriptions everywhere** - Future users will thank you
6. **Version control** - Track dashboard JSON in git with meaningful commit messages

---

**Remember**: The grid system is **6 columns**, not 12! This is the #1 cause of widget snapping issues.
