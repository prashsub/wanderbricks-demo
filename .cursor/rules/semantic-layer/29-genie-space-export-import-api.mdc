---
description: Comprehensive patterns for Databricks Genie Space Export/Import API - JSON schema, serialization format, and programmatic deployment
globs: src/genie/**/*.py, src/genie/**/*.json, context/genie/*.json
alwaysApply: false
---
# Databricks Genie Space Export/Import API Patterns

## Pattern Recognition

When programmatically creating, exporting, or importing Genie Spaces via the REST API, follow this structured schema for the `serialized_space` JSON format. This rule documents the complete GenieSpaceExport schema for API-based deployments.

---

## API Endpoints

### Official API Documentation

- [Create Space](https://docs.databricks.com/api/workspace/genie/createspace)
- [Update Space](https://docs.databricks.com/api/workspace/genie/updatespace)
- [List Spaces](https://docs.databricks.com/api/workspace/genie/listspaces)
- [Trash Space](https://docs.databricks.com/api/workspace/genie/trashspace)

---

### List All Genie Spaces

```bash
GET /api/2.0/genie/spaces
Authorization: Bearer <your_personal_access_token>
```

**Response:**
```json
{
  "spaces": [
    {
      "space_id": "01ef274d35a310b5bffd01dadcbaf577",
      "title": "Sales Analytics",
      "description": "Natural language sales analysis",
      "warehouse_id": "abc123def456"
    },
    {
      "space_id": "01ef274d35a310b5bffd01dadcbaf588",
      "title": "Cost Intelligence",
      "description": "FinOps and cost analytics",
      "warehouse_id": "abc123def456"
    }
  ]
}
```

**Use Case:** Discover existing spaces, check if space already exists before creating

---

### Export/Get a Genie Space

```bash
GET /api/2.0/genie/spaces/{space_id}?include_serialized_space=true
Authorization: Bearer <your_personal_access_token>
```

**Response:**
```json
{
  "space_id": "01ef274d35a310b5bffd01dadcbaf577",
  "title": "My Space",
  "description": "My Space Description",
  "warehouse_id": "abc123def456",
  "serialized_space": "{\n  \"version\": 1,\n  \"config\": {...}\n}"
}
```

**Use Case:** Export configuration for version control, backup, or migration

---

### Create a New Genie Space

```bash
POST /api/2.0/genie/spaces
Authorization: Bearer <your_personal_access_token>
Content-Type: application/json

{
  "title": "My New Space",
  "description": "Description here",
  "warehouse_id": "abc123def456",
  "parent_path": "/Workspace/Users/user@company.com/Genie Spaces",
  "serialized_space": "{...escaped JSON string...}"
}
```

**Response:**
```json
{
  "space_id": "01ef274d35a310b5bffd01dadcbaf577",
  "title": "My New Space",
  "description": "Description here",
  "warehouse_id": "abc123def456",
  "serialized_space": "{\n  \"version\": 1,\n  \"config\": {...}\n}"
}
```

**Use Case:** Programmatic deployment, CI/CD pipelines, environment promotion

---

### Update an Existing Genie Space

```bash
PATCH /api/2.0/genie/spaces/{space_id}
Authorization: Bearer <your_personal_access_token>
Content-Type: application/json

{
  // All fields optional - only include fields you want to update
  "title": "My Updated Space",
  "description": "Updated description",
  "warehouse_id": "abc123def456",
  "parent_path": "/Workspace/Users/user@company.com/Genie Spaces",
  "serialized_space": "{...updated JSON string...}"
}
```

**Response:**
```json
{
  "space_id": "01ef274d35a310b5bffd01dadcbaf577",
  "title": "My Updated Space",
  "description": "Updated description",
  "warehouse_id": "abc123def456",
  "serialized_space": "{\n  \"version\": 1,\n  \"config\": {...}\n}"
}
```

**Key Points:**
- **PATCH is partial update** - Only include fields you want to change
- **`serialized_space`** - If provided, completely replaces the space configuration
- **`parent_path`** - Optional, allows moving the space to a different folder
- **All fields optional** - Update title only, config only, or any combination

**Use Case:** Incremental updates, configuration changes, adding benchmarks

---

### Delete/Trash a Genie Space

```bash
DELETE /api/2.0/genie/spaces/{space_id}
Authorization: Bearer <your_personal_access_token>
```

**Response:**
```json
{
  "space_id": "01ef274d35a310b5bffd01dadcbaf577"
}
```

**Use Case:** Cleanup, decommissioning, environment teardown

⚠️ **Warning:** This permanently deletes the Genie Space and cannot be undone.

---

### Using Databricks CLI

```bash
# List all spaces
databricks api get /api/2.0/genie/spaces --profile <profile>

# Export/Get space
databricks api get "/api/2.0/genie/spaces/{space_id}?include_serialized_space=true" --profile <profile>

# Create space (POST with JSON body)
databricks api post /api/2.0/genie/spaces --profile <profile> --json '{...}'

# Update space (PATCH with JSON body)
databricks api patch "/api/2.0/genie/spaces/{space_id}" --profile <profile> --json '{...}'

# Delete/Trash space
databricks api delete "/api/2.0/genie/spaces/{space_id}" --profile <profile>
```

---

## Complete Schema Reference

### Top-Level Structure

```typescript
interface GenieSpaceExport {
  version: number;                    // Schema version (currently 1)
  config?: GenieSpaceConfig;          // Space-level configuration
  data_sources?: DataSources;         // Tables and metric views
  instructions?: Instructions;         // LLM instructions, TVFs, joins
  benchmarks?: Benchmarks;            // Evaluation questions
}
```

### API Wrapper Structure

```json
{
  "description": "Natural language description for users",
  "serialized_space": "{...JSON string of GenieSpaceExport...}",
  "space_id": "01f0ad0d629b11879bb8c06e03b919f8",
  "title": "Display Name",
  "warehouse_id": "4b9b953939869799"
}
```

---

## Section 1: Config - Sample Questions

### Schema

```typescript
interface GenieSpaceConfig {
  sample_questions: SampleQuestion[];
}

interface SampleQuestion {
  id: string;        // UUID without dashes (32 hex chars)
  question: string[]; // Array of strings (split at newlines)
}
```

### Pattern

```json
{
  "config": {
    "sample_questions": [
      {
        "id": "01f0ad3bc23713a48b30c9fbe1792b64",
        "question": ["What are the top 10 stores by revenue this month?"]
      },
      {
        "id": "01f0ad3bc2361bebb2f6bb245992759f",
        "question": ["Which stores are out of stock for Copenhagen?"]
      }
    ]
  }
}
```

### Best Practices

- **6-10 sample questions** - Cover major use cases
- **Questions are arrays** - Even single-line questions are `["question text"]`
- **IDs are UUIDs** - 32 hex characters without dashes
- **Variety** - Include different question types (rankings, comparisons, trends)

---

## Section 2: Data Sources - Tables

### Schema

```typescript
interface DataSources {
  tables?: Table[];
  metric_views?: MetricView[];
}

interface Table {
  identifier: string;           // Full 3-part UC name
  description?: string[];       // Array of description lines
  column_configs?: ColumnConfig[];
}

interface ColumnConfig {
  column_name: string;
  description?: string[];
  synonyms?: string[];
  exclude?: boolean;
  get_example_values?: boolean;      // Sample values for LLM context
  build_value_dictionary?: boolean;  // Build lookup index for categorical columns
}
```

### Pattern - Table Configuration

```json
{
  "data_sources": {
    "tables": [
      {
        "identifier": "catalog.schema.dim_store",
        "column_configs": [
          {
            "column_name": "store_number",
            "get_example_values": true,
            "build_value_dictionary": true
          },
          {
            "column_name": "state",
            "get_example_values": true,
            "build_value_dictionary": true
          },
          {
            "column_name": "store_type",
            "get_example_values": true,
            "build_value_dictionary": true
          },
          {
            "column_name": "latitude",
            "get_example_values": true
          }
        ]
      }
    ]
  }
}
```

### Column Configuration Best Practices

| Column Type | `get_example_values` | `build_value_dictionary` |
|-------------|---------------------|-------------------------|
| **Categorical** (state, brand, type) | `true` | `true` |
| **Identifier** (store_number, upc_code) | `true` | `true` |
| **Date/Timestamp** | `true` | `false` |
| **Numeric** (revenue, quantity) | `true` | `false` |
| **Boolean** (is_current, is_premium) | `true` | `false` |
| **High-cardinality text** (description) | `false` | `false` |

**Rule:** Use `build_value_dictionary: true` for columns users will filter by text (e.g., "Copenhagen", "California").

---

## Section 3: Data Sources - Metric Views

### Schema

```typescript
interface MetricView {
  identifier: string;      // Full 3-part UC name
  description?: string[];  // Array of description lines
  column_configs?: ColumnConfig[];  // Same as table column configs
}
```

### Pattern

```json
{
  "data_sources": {
    "metric_views": [
      {
        "identifier": "catalog.schema.sales_performance_metrics",
        "column_configs": [
          {
            "column_name": "total_revenue"
          },
          {
            "column_name": "brand",
            "get_example_values": true,
            "build_value_dictionary": true
          },
          {
            "column_name": "store_type",
            "get_example_values": true,
            "build_value_dictionary": true
          }
        ]
      }
    ]
  }
}
```



### ⚠️ CRITICAL: column_configs Triggers Unity Catalog Validation

**Discovery (Production Deployment)**:

`column_configs` causes the Databricks API to perform Unity Catalog schema validation during Genie Space creation/update. For complex spaces with many tables or metric views, this validation can fail with:

```
INTERNAL_ERROR: Failed to retrieve schema from unity catalog
```

**Pattern Observed**:
- Spaces with NO `column_configs` → ✅ Deployed successfully
- Spaces with extensive `column_configs` (67-124 configs) → ❌ INTERNAL_ERROR

**Recommendation**:

**Start Simple:**
```json
{
  "data_sources": {
    "metric_views": [
      {
        "identifier": "catalog.schema.mv_sales",
        // ✅ NO column_configs - deploys successfully
      }
    ]
  }
}
```

**Add Incrementally (Optional):**
```json
{
  "data_sources": {
    "metric_views": [
      {
        "identifier": "catalog.schema.mv_sales",
        "column_configs": [
          {
            "column_name": "store_name",
            "get_example_values": true,
            "build_value_dictionary": true
          }
        ]
      }
    ]
  }
}
```

**Test after each addition** - If INTERNAL_ERROR occurs, remove the last added config.

**Trade-off**:
- **Without column_configs**: Reliable deployment, but LLM has less column-level context
- **With column_configs**: More LLM context, but higher risk of Unity Catalog validation errors

---

## Section 4: Instructions - Text Instructions

### Schema

```typescript
interface Instructions {
  text_instructions?: TextInstruction[];
  example_question_sqls?: ExampleQuestionSql[];
  sql_functions?: SqlFunction[];
  join_specs?: JoinSpec[];
}

interface TextInstruction {
  id: string;       // UUID without dashes
  content?: string[]; // Array of instruction lines
}
```

### Pattern

```json
{
  "instructions": {
    "text_instructions": [
      {
        "id": "01f0ad1010c212a7a17001b551b71dec",
        "content": [
          "BUSINESS CONTEXT:\n",
          "Altria tobacco products (Copenhagen, Marlboro, Skoal, Parliament) sold at 7-Eleven stores.\n",
          "\n",
          "DATA ASSETS:\n",
          "1. sales_performance_metrics - Daily sales by store/product.\n",
          "2. inventory_health_metrics - Current inventory positions.\n",
          "\n",
          "KEY METRICS:\n",
          "• Revenue: Use net_revenue (gross - returns - discounts).\n",
          "• Volume: Units sold minus returns.\n",
          "\n",
          "TIME FILTERS:\n",
          "• \"last 7 days\" → WHERE transaction_date >= CURRENT_DATE - 7\n",
          "• \"this month\" → WHERE is_current_month = true\n",
          "\n",
          "BUSINESS RULES:\n",
          "• Store numbers are strings (e.g., '101', '150')\n",
          "• For stores, filter dim_store.is_current = true (SCD Type 2)\n",
          "• Use TOP N for rankings (default TOP 10)"
        ]
      }
    ]
  }
}
```

### Text Instruction Structure (Template)

```
BUSINESS CONTEXT:
[1-2 lines describing the business domain]

DATA ASSETS:
1. [metric_view_1] - [purpose]
2. [metric_view_2] - [purpose]
3. TVFs: [function_list]

KEY METRICS:
• [Metric 1]: [definition and synonyms]
• [Metric 2]: [definition and synonyms]

TIME FILTERS:
• "[user phrase]" → [SQL pattern]

AGGREGATIONS:
• "by [dimension]" → GROUP BY [column]

FILTERS:
• "[term]" → [column] = '[value]'

BUSINESS RULES:
• [Rule 1]
• [Rule 2]
• [Default behaviors]
```

---

## Section 5: Instructions - SQL Functions (TVFs)

### Schema

```typescript
interface SqlFunction {
  id: string;         // UUID without dashes
  identifier: string; // Full 3-part function name
}
```

### Pattern

```json
{
  "instructions": {
    "sql_functions": [
      {
        "id": "01f0ad0f09081561ba6de2829ed2fa02",
        "identifier": "catalog.schema.get_low_stock_items"
      },
      {
        "id": "01f0ad0f1d5012f5827579bc338a7e31",
        "identifier": "catalog.schema.get_sales_trend"
      },
      {
        "id": "01f0ad21813418dc814c489e6e08476b",
        "identifier": "catalog.schema.compare_brand_performance"
      }
    ]
  }
}
```

### Best Practices

- **Include ALL TVFs** the space should use
- **Functions must exist** in Unity Catalog before import
- **Document in text_instructions** how/when to use each TVF

---

## Section 6: Instructions - Join Specifications

### Schema

```typescript
interface JoinSpec {
  id: string;
  left: JoinSource;
  right: JoinSource;
  sql: string[];       // Join condition + relationship type marker
  comment?: string[];  // Optional description
}

interface JoinSource {
  identifier: string;  // Full 3-part name
  alias: string;       // Table alias for SQL
}
```

### Pattern

```json
{
  "instructions": {
    "join_specs": [
      {
        "id": "01f0ad0d633619c7b3f7c7fbc9ac975e",
        "left": {
          "identifier": "catalog.schema.fact_inventory_snapshot",
          "alias": "fact_inventory_snapshot"
        },
        "right": {
          "identifier": "catalog.schema.dim_product",
          "alias": "dim_product"
        },
        "sql": [
          "`fact_inventory_snapshot`.`product_key` = `dim_product`.`product_key`",
          "--rt=FROM_RELATIONSHIP_TYPE_MANY_TO_ONE--"
        ]
      },
      {
        "id": "01f0ad0d63361dc9870d5df2e3eefdee",
        "left": {
          "identifier": "catalog.schema.fact_sales_daily",
          "alias": "fact_sales_daily"
        },
        "right": {
          "identifier": "catalog.schema.dim_store",
          "alias": "dim_store"
        },
        "sql": [
          "`fact_sales_daily`.`store_key` = `dim_store`.`store_key`",
          "--rt=FROM_RELATIONSHIP_TYPE_MANY_TO_ONE--"
        ]
      }
    ]
  }
}
```

### Relationship Type Markers

| Marker | Meaning |
|--------|---------|
| `--rt=FROM_RELATIONSHIP_TYPE_MANY_TO_ONE--` | Fact → Dimension (most common) |
| `--rt=FROM_RELATIONSHIP_TYPE_ONE_TO_MANY--` | Dimension → Fact |
| `--rt=FROM_RELATIONSHIP_TYPE_MANY_TO_MANY--` | Many-to-many (rare) |
| `--rt=FROM_RELATIONSHIP_TYPE_ONE_TO_ONE--` | One-to-one |

### Join Specification Best Practices

1. **Use backticks** around table and column names
2. **Aliases match table names** for clarity
3. **Star schema pattern**: Fact tables on left, dimensions on right
4. **Include all FK relationships** between tables in data_sources

---

## Section 7: Benchmarks - Evaluation Questions

### Schema

```typescript
interface Benchmarks {
  questions: BenchmarkQuestion[];
}

interface BenchmarkQuestion {
  id: string;
  question: string[];
  answer: BenchmarkAnswer[];  // Currently only one answer supported
}

interface BenchmarkAnswer {
  format: "SQL";     // Only SQL format supported
  content: string[]; // SQL query split by newlines
}
```

### Pattern

```json
{
  "benchmarks": {
    "questions": [
      {
        "id": "01f0ad1423bb14d2b1292a60baa4d4e2",
        "question": ["What are the top 10 stores by revenue this month?"],
        "answer": [
          {
            "format": "SQL",
            "content": [
              "SELECT \n",
              "  store_number,\n",
              "  store_name,\n",
              "  MEASURE(total_revenue) as total_revenue\n",
              "FROM catalog.schema.sales_performance_metrics\n",
              "WHERE month = MONTH(CURRENT_DATE) AND year = YEAR(CURRENT_DATE)\n",
              "GROUP BY ALL\n",
              "ORDER BY total_revenue DESC\n",
              "LIMIT 10;"
            ]
          }
        ]
      },
      {
        "id": "01f0b9f1ba451339b3eff1bd888f642a",
        "question": ["Show me sales trend for the last 30 days"],
        "answer": [
          {
            "format": "SQL",
            "content": [
              "SELECT * \n",
              "FROM catalog.schema.get_sales_trend(30);"
            ]
          }
        ]
      }
    ]
  }
}
```

### Benchmark Question Coverage

Include questions that test:
- [ ] **Metric view aggregations** - Revenue, counts, averages
- [ ] **TVF usage** - Parameterized queries
- [ ] **Time filtering** - This month, last 30 days, YTD
- [ ] **Dimension filtering** - By brand, store, state
- [ ] **Rankings** - Top N, bottom N
- [ ] **Comparisons** - X vs Y, trends
- [ ] **Complex queries** - CTEs, window functions

---

## Complete Example: Minimal Genie Space

```json
{
  "version": 1,
  "config": {
    "sample_questions": [
      {
        "id": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
        "question": ["What is the total revenue this month?"]
      },
      {
        "id": "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
        "question": ["Which stores have the highest sales?"]
      }
    ]
  },
  "data_sources": {
    "metric_views": [
      {
        "identifier": "catalog.schema.sales_metrics",
        "column_configs": [
          {
            "column_name": "total_revenue"
          },
          {
            "column_name": "store_name",
            "get_example_values": true,
            "build_value_dictionary": true
          }
        ]
      }
    ]
  },
  "instructions": {
    "text_instructions": [
      {
        "id": "cccccccccccccccccccccccccccccccc",
        "content": [
          "You are a sales analytics assistant.\n",
          "Use the sales_metrics metric view for all queries.\n",
          "Default to current month if no time period specified."
        ]
      }
    ]
  },
  "benchmarks": {
    "questions": [
      {
        "id": "dddddddddddddddddddddddddddddddd",
        "question": ["Total revenue this month"],
        "answer": [
          {
            "format": "SQL",
            "content": [
              "SELECT MEASURE(total_revenue) as revenue\n",
              "FROM catalog.schema.sales_metrics\n",
              "WHERE month = MONTH(CURRENT_DATE);"
            ]
          }
        ]
      }
    ]
  }
}
```

---

## ID Generation Pattern

### UUID Format

IDs are 32-character hex strings (UUID without dashes):

```python
import uuid

def generate_genie_id():
    """Generate a Genie Space compatible ID."""
    return uuid.uuid4().hex  # Returns 32 hex chars without dashes

# Example: "01f0ad0d629b11879bb8c06e03b919f8"
```

### ID Assignment

| Object | ID Required | Notes |
|--------|-------------|-------|
| `sample_questions[].id` | Yes | Unique within space |
| `text_instructions[].id` | Yes | Unique within space |
| `sql_functions[].id` | Yes | Unique within space |
| `join_specs[].id` | Yes | Unique within space |
| `benchmarks.questions[].id` | Yes | Unique within space |
| `example_question_sqls[].id` | Yes | Unique within space |

---

## Serialization Pattern

### Python Example

```python
import json

def create_genie_space_payload(
    title: str,
    description: str,
    warehouse_id: str,
    serialized_space: dict
) -> dict:
    """Create the API payload for creating/updating a Genie Space."""
    return {
        "title": title,
        "description": description,
        "warehouse_id": warehouse_id,
        "serialized_space": json.dumps(serialized_space, indent=2)
    }

# Usage
space_config = {
    "version": 1,
    "config": {...},
    "data_sources": {...},
    "instructions": {...},
    "benchmarks": {...}
}

payload = create_genie_space_payload(
    title="My Analytics Space",
    description="Natural language interface for sales analytics",
    warehouse_id="abc123def456",
    serialized_space=space_config
)

# Convert to JSON string for API call
api_body = json.dumps(payload)
```

---

## ⚠️ CRITICAL: Exact Format Requirements (From Reference)

### Reference File: `context/genie/genie_space_export.json`

This is a **production Databricks Genie Space export**. All new Genie Spaces MUST match this exact structure.

---

### Field-Level Format Requirements

#### config.sample_questions

**✅ CORRECT (Reference Format):**
```json
{
  "config": {
    "sample_questions": [
      {
        "id": "01f0ad3bc23713a48b30c9fbe1792b64",
        "question": ["What are the top 10 stores by revenue this month?"]
      }
    ]
  }
}
```

**❌ WRONG:**
```json
{
  "config": {
    "sample_questions": [
      "What are the top 10 stores by revenue this month?"  // ❌ String instead of object
    ]
  }
}
```

**❌ WRONG:**
```json
{
  "config": {
    "sample_questions": [
      {
        "question": "What is the revenue?"  // ❌ String instead of array
      }
    ]
  }
}
```

---

#### data_sources.metric_views

**✅ CORRECT (Reference Format):**
```json
{
  "data_sources": {
    "metric_views": [
      {
        "identifier": "catalog.schema.sales_performance_metrics",
        "column_configs": [
          {
            "column_name": "total_revenue"
          },
          {
            "column_name": "brand",
            "get_example_values": true,
            "build_value_dictionary": true
          }
        ]
      }
    ]
  }
}
```

**❌ WRONG:**
```json
{
  "data_sources": {
    "metric_views": [
      {
        "id": "abc123",                    // ❌ Remove 'id' field
        "name": "sales_metrics",           // ❌ Remove 'name' field
        "full_name": "catalog.schema.mv",  // ❌ Should be 'identifier'
        "description": "..."
      }
    ]
  }
}
```

**Valid Fields for metric_views**:
- ✅ `identifier` (required) - Full 3-part UC name
- ✅ `description` (optional) - Array of strings
- ✅ `column_configs` (optional) - Array of column config objects
- ❌ `id`, `name`, `full_name` - NOT allowed

---

#### data_sources.tables

**✅ CORRECT (Reference Format):**
```json
{
  "data_sources": {
    "tables": [
      {
        "identifier": "catalog.schema.dim_store",
        "column_configs": [
          {
            "column_name": "store_number",
            "get_example_values": true,
            "build_value_dictionary": true
          }
        ]
      }
    ]
  }
}
```

**Valid Fields for tables**:
- ✅ `identifier` (required) - Full 3-part UC name
- ✅ `description` (optional) - Array of strings
- ✅ `column_configs` (optional) - Array of column config objects
- ❌ `id`, `name`, `full_name` - NOT allowed

---

#### instructions.sql_functions

**✅ CORRECT (Reference Format):**
```json
{
  "instructions": {
    "sql_functions": [
      {
        "id": "01f0ad0f09081561ba6de2829ed2fa02",
        "identifier": "catalog.schema.get_low_stock_items"
      }
    ]
  }
}
```

**❌ WRONG:**
```json
{
  "instructions": {
    "sql_functions": [
      {
        "identifier": "catalog.schema.get_function"  // ❌ Missing 'id' field
      }
    ]
  }
}
```

**❌ WRONG:**
```json
{
  "instructions": {
    "sql_functions": [
      {
        "id": "...",
        "identifier": "catalog.schema.function",
        "name": "function",              // ❌ Extra field
        "signature": "function(x, y)",   // ❌ Extra field
        "full_name": "...",              // ❌ Extra field
        "description": "..."             // ❌ Extra field
      }
    ]
  }
}
```

**Required Fields for sql_functions**:
- ✅ `id` (required) - 32 hex character UUID
- ✅ `identifier` (required) - Full 3-part function name
- ❌ NO other fields allowed

---

#### instructions.text_instructions

**✅ CORRECT (Reference Format):**
```json
{
  "instructions": {
    "text_instructions": [
      {
        "id": "01f0ad1010c212a7a17001b551b71dec",
        "content": [
          "BUSINESS CONTEXT:\n",
          "Description here.\n",
          "\n",
          "DATA ASSETS:\n",
          "1. metric_view_1 - Purpose\n"
        ]
      }
    ]
  }
}
```

**Required Fields for text_instructions**:
- ✅ `id` (required) - 32 hex character UUID
- ✅ `content` (optional) - Array of strings (each string can have `\n`)
- ❌ NO other fields allowed

---

## Validation Checklist

### Structure Validation (MANDATORY)

- [ ] `version` is set to `1` (integer)
- [ ] All IDs are 32-character hex strings (no dashes)
- [ ] All string arrays (question, content, sql) are arrays even for single values
- [ ] All identifiers use full 3-part UC names (`catalog.schema.object`)

### config.sample_questions

- [ ] Is an array of **objects** (not strings)
- [ ] Each object has `id` field (32 hex chars)
- [ ] Each object has `question` field (array of strings)
- [ ] No other fields present

### data_sources.tables

- [ ] Each table has `identifier` field (full 3-part name)
- [ ] `identifier` contains no template variables (`${...}`) in final JSON
- [ ] If `column_configs` present, it's an array
- [ ] Each column_config has `column_name` field
- [ ] NO `id`, `name`, or `full_name` fields present

### data_sources.metric_views

- [ ] Each metric view has `identifier` field (full 3-part name)
- [ ] `identifier` contains no template variables in final JSON
- [ ] If `column_configs` present, it's an array
- [ ] NO `id`, `name`, or `full_name` fields present

### instructions.sql_functions

- [ ] Each function has `id` field (32 hex chars)
- [ ] Each function has `identifier` field (full 3-part function name)
- [ ] NO other fields (`name`, `signature`, `full_name`, `description`)

### instructions.text_instructions

- [ ] Each instruction has `id` field (32 hex chars)
- [ ] If `content` present, it's an array of strings
- [ ] NO other fields present

### benchmarks.questions

- [ ] Each question has `id` field (32 hex chars)
- [ ] Each question has `question` field (array of strings)
- [ ] Each question has `answer` array
- [ ] Each answer has `format: "SQL"`
- [ ] Each answer has `content` (array of strings)

---

## ⚠️ CRITICAL: Common Production Errors & Fixes

Based on production deployment failures, these are the most common format errors that cause `BAD_REQUEST`, `INVALID_PARAMETER_VALUE`, and `INTERNAL_ERROR` responses from the Databricks API.

---

### Error 1: sample_questions as Plain Strings

**Error**: `BAD_REQUEST: Invalid JSON in field 'serialized_space'`

**Problem**: sample_questions are plain strings instead of objects with id/question

```python
# Fix script
import json
import uuid

with open('genie_export.json', 'r') as f:
    data = json.load(f)

# Convert strings to objects
if isinstance(data["config"]["sample_questions"][0], str):
    new_sq = []
    for q_text in data["config"]["sample_questions"]:
        new_sq.append({
            "id": uuid.uuid4().hex,
            "question": [q_text]
        })
    data["config"]["sample_questions"] = new_sq

with open('genie_export.json', 'w') as f:
    json.dump(data, f, indent=2)
```

---

### Error 2: metric_views with full_name Instead of identifier

**Error**: `BAD_REQUEST: Invalid JSON in field 'serialized_space'`

**Problem**: metric_views have `{id, name, full_name}` instead of `{identifier}`

```python
# Fix script
for mv in data["data_sources"]["metric_views"]:
    if "full_name" in mv:
        # Transform to API format
        new_mv = {"identifier": mv["full_name"]}
        if "description" in mv:
            new_mv["description"] = mv["description"]
        if "column_configs" in mv:
            new_mv["column_configs"] = mv["column_configs"]
        
        # Replace with fixed version
        data["data_sources"]["metric_views"][i] = new_mv
```

---

### Error 3: sql_functions Missing id Field

**Error**: `INTERNAL_ERROR: Failed to retrieve schema from unity catalog`

**Problem**: sql_functions only have `{identifier}`, missing required `{id}` field

```python
# Fix script
for func in data["instructions"]["sql_functions"]:
    if "id" not in func:
        func["id"] = uuid.uuid4().hex
```

---

### Error 4: sample_questions with String Instead of Array

**Error**: `INVALID_PARAMETER_VALUE: Expected an array for question but found "string"`

**Problem**: question field is a string instead of array

```python
# Fix script
for sq in data["config"]["sample_questions"]:
    if isinstance(sq["question"], str):
        sq["question"] = [sq["question"]]
```

---

### Error 5: config.name and config.description

**Error**: `BAD_REQUEST: Invalid JSON in field 'serialized_space'`

**Problem**: `config.name` and `config.description` should NOT be in the config section

```python
# Fix script
if "config" in data:
    if "name" in data["config"]:
        del data["config"]["name"]
    if "description" in data["config"]:
        del data["config"]["description"]
```

**Note**: `title` and `description` belong at the top level of the API payload, not in `serialized_space.config`.

---

### Error 6: Missing data_sources.tables Array

**Error**: `BAD_REQUEST: Invalid JSON in field 'serialized_space'`

**Problem**: Missing `tables` array (must be present even if empty)

```python
# Fix script
if "data_sources" not in data:
    data["data_sources"] = {}
if "tables" not in data["data_sources"]:
    data["data_sources"]["tables"] = []
```

---

### Error 7: sql_functions with Extra Fields

**Error**: `BAD_REQUEST: Invalid JSON in field 'serialized_space'`

**Problem**: sql_functions have extra fields like `name`, `signature`, `full_name`, `description`

```python
# Fix script
new_sql_functions = []
for func in data["instructions"]["sql_functions"]:
    new_sql_functions.append({
        "id": func["id"],
        "identifier": func.get("full_name") or func.get("identifier")
    })
data["instructions"]["sql_functions"] = new_sql_functions
```

---

### Error 8: text_instructions as Array of Strings

**Error**: `BAD_REQUEST: Invalid JSON in field 'serialized_space'`

**Problem**: text_instructions are plain strings instead of objects with id/content

```python
# Fix script
if isinstance(data["instructions"]["text_instructions"][0], str):
    new_ti = [{
        "id": uuid.uuid4().hex,
        "content": data["instructions"]["text_instructions"]
    }]
    data["instructions"]["text_instructions"] = new_ti
```

---

## Validation Checklist

### Structure Validation (MANDATORY)

- [ ] `version` is set to `1` (integer)
- [ ] All IDs are 32-character hex strings (no dashes)
- [ ] All string arrays (question, content, sql) are arrays even for single values
- [ ] All identifiers use full 3-part UC names (`catalog.schema.object`)

### config.sample_questions (CRITICAL)

- [ ] ✅ Is an array of **objects** (not strings)
- [ ] ✅ Each object has `id` field (32 hex chars)
- [ ] ✅ Each object has `question` field (array of strings, even if single string)
- [ ] ✅ No other fields (no `name`, `description`)

### data_sources.tables

- [ ] ✅ Each table has `identifier` field (full 3-part name, no template variables after substitution)
- [ ] ✅ NO `id`, `name`, or `full_name` fields present
- [ ] ✅ If `column_configs` present, it's an array
- [ ] ✅ Each column_config has `column_name` field
- [ ] Optional: `description` field (array of strings)

### data_sources.metric_views

- [ ] ✅ Each metric view has `identifier` field (full 3-part name, no template variables after substitution)
- [ ] ✅ NO `id`, `name`, or `full_name` fields present
- [ ] ✅ If `column_configs` present, it's an array
- [ ] Optional: `description` field (array of strings)

### instructions.sql_functions (CRITICAL)

- [ ] ✅ Each function has `id` field (32 hex chars) - REQUIRED
- [ ] ✅ Each function has `identifier` field (full 3-part function name) - REQUIRED
- [ ] ✅ NO other fields (`name`, `signature`, `full_name`, `description`) - Will cause errors

### instructions.text_instructions

- [ ] ✅ Each instruction has `id` field (32 hex chars)
- [ ] ✅ If `content` present, it's an array of strings (each string can contain `\n`)
- [ ] ✅ NO other fields present

### benchmarks.questions

- [ ] Each question has `id` field (32 hex chars)
- [ ] Each question has `question` field (array of strings)
- [ ] Each question has `answer` array with one element
- [ ] Each answer has `format: "SQL"`
- [ ] Each answer has `content` (array of strings split by lines)

---

## Deployment Script Pattern

```python
#!/usr/bin/env python3
"""Deploy Genie Space via API."""

import json
import requests
import uuid

def generate_id():
    return uuid.uuid4().hex

def deploy_genie_space(
    host: str,
    token: str,
    title: str,
    description: str,
    warehouse_id: str,
    config: dict
):
    """Create a new Genie Space using the REST API."""
    
    url = f"{host}/api/2.0/genie/spaces"
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json"
    }
    
    payload = {
        "title": title,
        "description": description,
        "warehouse_id": warehouse_id,
        "serialized_space": json.dumps(config)
    }
    
    response = requests.post(url, headers=headers, json=payload)
    response.raise_for_status()
    
    result = response.json()
    print(f"✓ Created Genie Space: {result['space_id']}")
    return result

def update_genie_space(
    host: str,
    token: str,
    space_id: str,
    title: str = None,
    description: str = None,
    warehouse_id: str = None,
    config: dict = None,
    parent_path: str = None
):
    """Update an existing Genie Space using the REST API.
    
    All parameters except space_id are optional - only include what you want to update.
    """
    
    url = f"{host}/api/2.0/genie/spaces/{space_id}"
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json"
    }
    
    # Build payload with only provided fields
    payload = {}
    if title is not None:
        payload["title"] = title
    if description is not None:
        payload["description"] = description
    if warehouse_id is not None:
        payload["warehouse_id"] = warehouse_id
    if config is not None:
        payload["serialized_space"] = json.dumps(config)
    if parent_path is not None:
        payload["parent_path"] = parent_path
    
    response = requests.patch(url, headers=headers, json=payload)
    response.raise_for_status()
    
    result = response.json()
    print(f"✓ Updated Genie Space: {result['space_id']}")
    return result

def list_genie_spaces(
    host: str,
    token: str
):
    """List all Genie Spaces in the workspace."""
    
    url = f"{host}/api/2.0/genie/spaces"
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json"
    }
    
    response = requests.get(url, headers=headers)
    response.raise_for_status()
    
    result = response.json()
    spaces = result.get("spaces", [])
    print(f"✓ Found {len(spaces)} Genie Spaces")
    for space in spaces:
        print(f"  - {space['title']} ({space['space_id']})")
    return result

def get_genie_space(
    host: str,
    token: str,
    space_id: str,
    include_config: bool = True
):
    """Get a specific Genie Space configuration."""
    
    url = f"{host}/api/2.0/genie/spaces/{space_id}"
    if include_config:
        url += "?include_serialized_space=true"
    
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json"
    }
    
    response = requests.get(url, headers=headers)
    response.raise_for_status()
    
    result = response.json()
    print(f"✓ Retrieved Genie Space: {result['title']} ({result['space_id']})")
    return result

def delete_genie_space(
    host: str,
    token: str,
    space_id: str
):
    """Delete/trash a Genie Space.
    
    WARNING: This permanently deletes the space and cannot be undone.
    """
    
    url = f"{host}/api/2.0/genie/spaces/{space_id}"
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json"
    }
    
    response = requests.delete(url, headers=headers)
    response.raise_for_status()
    
    result = response.json()
    print(f"✓ Deleted Genie Space: {result['space_id']}")
    return result

# Example usage
if __name__ == "__main__":
    host = "https://your-workspace.cloud.databricks.com"
    token = "your-token"
    warehouse_id = "abc123"
    
    # 1. List existing spaces
    existing_spaces = list_genie_spaces(host, token)
    
    # 2. Create new space
    config = {
        "version": 1,
        "config": {
            "sample_questions": [
                {"id": generate_id(), "question": ["Top 10 stores by revenue?"]}
            ]
        },
        "data_sources": {
            "metric_views": [
                {
                    "identifier": "catalog.schema.sales_metrics",
                    "column_configs": [
                        {"column_name": "total_revenue"},
                        {"column_name": "store_name", "build_value_dictionary": True}
                    ]
                }
            ]
        },
        "instructions": {
            "text_instructions": [
                {"id": generate_id(), "content": ["Sales analytics assistant."]}
            ]
        },
        "benchmarks": {
            "questions": []
        }
    }
    
    result = deploy_genie_space(
        host=host,
        token=token,
        title="Sales Analytics",
        description="Natural language sales analysis",
        warehouse_id=warehouse_id,
        config=config
    )
    
    space_id = result['space_id']
    
    # 3. Get/export the space
    exported = get_genie_space(host, token, space_id, include_config=True)
    
    # 4. Update existing space - only update specific fields
    update_genie_space(
        host=host,
        token=token,
        space_id=space_id,
        title="Sales Analytics - Updated",  # Update title only
        description="Updated description"  # Update description only
        # config not included - keeps existing configuration
    )
    
    # 5. Update configuration only
    updated_config = {**config}  # Copy existing config
    updated_config["config"]["sample_questions"].append(
        {"id": generate_id(), "question": ["What was last month's revenue?"]}
    )
    
    update_genie_space(
        host=host,
        token=token,
        space_id=space_id,
        config=updated_config  # Only update config, keep title/description
    )
    
    # 6. Delete space (use with caution!)
    # delete_genie_space(host, token, space_id)
```

---

## API Operations Summary

| Operation | Method | Endpoint | Use Case |
|-----------|--------|----------|----------|
| **List Spaces** | GET | `/api/2.0/genie/spaces` | Discover existing spaces, check before creating |
| **Get Space** | GET | `/api/2.0/genie/spaces/{space_id}` | Export config, backup, version control |
| **Create Space** | POST | `/api/2.0/genie/spaces` | New deployment, CI/CD, environment setup |
| **Update Space** | PATCH | `/api/2.0/genie/spaces/{space_id}` | Modify config, add benchmarks, update metadata |
| **Delete Space** | DELETE | `/api/2.0/genie/spaces/{space_id}` | Cleanup, decommissioning, teardown |

### Workflow Patterns

**Initial Deployment:**
1. List spaces (check if already exists)
2. Create space with full configuration
3. Get space to verify deployment

**Incremental Updates:**
1. Get current space configuration
2. Modify specific sections
3. Update space with PATCH (partial update)

**Migration/Backup:**
1. Get space with `include_serialized_space=true`
2. Save JSON to version control
3. Create space in new environment

**Cleanup:**
1. List all spaces
2. Identify spaces to remove
3. Delete spaces individually

---

## References

### Official API Documentation
- [Create Space](https://docs.databricks.com/api/workspace/genie/createspace) - POST endpoint for new spaces
- [Update Space](https://docs.databricks.com/api/workspace/genie/updatespace) - PATCH endpoint for modifications
- [List Spaces](https://docs.databricks.com/api/workspace/genie/listspaces) - GET endpoint for discovery
- [Trash Space](https://docs.databricks.com/api/workspace/genie/trashspace) - DELETE endpoint for cleanup

### General Documentation
- [Genie Overview](https://docs.databricks.com/genie/)
- [Genie REST API](https://docs.databricks.com/api/workspace/genie)

### Related Cursor Rules
- [genie-space-patterns.mdc](mdc:.cursor/rules/semantic-layer/16-genie-space-patterns.mdc) - UI-based Genie Space setup
- [metric-views-patterns.mdc](mdc:.cursor/rules/semantic-layer/14-metric-views-patterns.mdc) - Metric view YAML
- [databricks-table-valued-functions.mdc](mdc:.cursor/rules/semantic-layer/15-databricks-table-valued-functions.mdc) - TVF patterns

### Project Files
- [Exported Genie Space Example](../../context/genie/genie_space_export_formatted.json)

---

## Production Deployment Checklist

Before deploying any Genie Space, run this comprehensive validation:

### Step 1: Validate JSON Structure

```bash
python3 scripts/validate_against_reference.py
```

**Expected**: "✅ ALL FILES MATCH REFERENCE STRUCTURE!"

**If errors found**: Run the appropriate fix scripts (see "Common Production Errors" section)

---

### Step 2: Validate SQL Queries

```bash
DATABRICKS_CONFIG_PROFILE=health-monitor databricks bundle run -t dev genie_benchmark_validation_job
```

**Expected**: 150/150 (100%) pass rate

**If errors found**: Fix SQL queries in `answer.content` sections

---

### Step 3: Deploy Genie Spaces

```bash
DATABRICKS_CONFIG_PROFILE=health-monitor databricks bundle deploy -t dev
DATABRICKS_CONFIG_PROFILE=health-monitor databricks bundle run -t dev genie_spaces_deployment_job
```

**Expected**: "✅ All Genie Spaces deployed successfully!"

---

### Step 4: Verify in UI

1. Navigate to Genie Spaces in Databricks UI
2. Test sample questions in each space
3. Verify data sources load correctly
4. Check that TVFs are accessible

---

### Common Deployment Errors

| Error Code | Cause | Fix |
|---|---|---|
| `BAD_REQUEST: Invalid JSON in field 'serialized_space'` | JSON structure mismatch | Run fix scripts for sample_questions, metric_views, sql_functions |
| `INVALID_PARAMETER_VALUE: Expected an array for question` | String instead of array | Fix sample_questions or benchmark questions format |
| `INTERNAL_ERROR: Failed to retrieve schema from unity catalog` | Transient API error OR invalid column_configs | Retry deployment, or remove column_configs temporarily |
| `TABLE_OR_VIEW_NOT_FOUND` in benchmark SQL | SQL query references non-existent table | Fix table names in benchmark queries |
| `COLUMN_NOT_FOUND` in benchmark SQL | SQL query references non-existent column | Fix column names using ground truth |

---

---

## ⚠️ CRITICAL: Asset Inventory-Driven Generation (Jan 2026)

### The Core Problem

**Manually editing JSON files leads to systematic deployment failures:**

| Session | Error | Root Cause |
|---------|-------|------------|
| Session 21-22 | `INTERNAL_ERROR: Failed to retrieve schema` | 36+ non-existent tables in data_sources |
| Session 23 | `Exceeded maximum number (50)` | 53 TVFs in unified_health_monitor |
| Session 24 | Hardcoded paths break cross-workspace | `prashanth_` prefix hardcoded |

### The Solution: Inventory-First Generation

**NEVER manually edit `data_sources` in JSON files. Generate from a verified asset inventory.**

---

### Asset Inventory Structure

**File: `src/genie/actual_assets_inventory.json`**

```json
{
  "metadata": {
    "generated_at": "2026-01-14T12:00:00Z",
    "catalog": "prashanth_subrahmanyam_catalog",
    "schemas_queried": [
      "dev_prashanth_subrahmanyam_system_gold",
      "dev_prashanth_subrahmanyam_system_gold_ml",
      "dev_prashanth_subrahmanyam_system_gold_monitoring"
    ]
  },
  "system_gold": {
    "tables": [
      {"identifier": "${catalog}.${gold_schema}.dim_workspace"},
      {"identifier": "${catalog}.${gold_schema}.dim_sku"},
      {"identifier": "${catalog}.${gold_schema}.fact_usage"}
    ],
    "metric_views": [
      {"identifier": "${catalog}.${gold_schema}.mv_cost_analytics"}
    ],
    "sql_functions": [
      {"identifier": "${catalog}.${gold_schema}.get_top_cost_contributors"}
    ]
  },
  "system_gold_ml": {
    "tables": [
      {"identifier": "${catalog}.${feature_schema}.budget_forecast_predictions"}
    ]
  },
  "system_gold_monitoring": {
    "tables": [
      {"identifier": "${catalog}.${gold_schema}_monitoring.fact_usage_profile_metrics"}
    ]
  },
  "genie_space_mappings": {
    "cost_intelligence": {
      "tables": ["${catalog}.${gold_schema}.dim_sku", "..."],
      "metric_views": ["${catalog}.${gold_schema}.mv_cost_analytics"],
      "sql_functions": ["${catalog}.${gold_schema}.get_top_cost_contributors"]
    }
  }
}
```

---

### Template Variable System

**CRITICAL: NEVER hardcode schema paths in JSON files.**

#### ❌ WRONG: Hardcoded Paths

```json
{
  "data_sources": {
    "tables": [
      {"identifier": "prashanth_subrahmanyam_catalog.dev_prashanth_subrahmanyam_system_gold.dim_workspace"}
    ]
  }
}
```

**Problems:**
- Breaks when deploying to different workspace
- Requires find/replace for each environment
- Error-prone manual process

#### ✅ CORRECT: Template Variables

```json
{
  "data_sources": {
    "tables": [
      {"identifier": "${catalog}.${gold_schema}.dim_workspace"}
    ]
  }
}
```

**Variables defined in `databricks.yml`:**

```yaml
variables:
  catalog:
    description: Unity Catalog name
    default: prashanth_subrahmanyam_catalog
  gold_schema:
    description: Gold layer schema
    default: dev_prashanth_subrahmanyam_system_gold
  feature_schema:
    description: ML features schema (system_gold_ml)
    default: dev_prashanth_subrahmanyam_system_gold_ml

targets:
  dev:
    variables:
      catalog: prashanth_subrahmanyam_catalog
      gold_schema: dev_prashanth_subrahmanyam_system_gold
  prod:
    variables:
      catalog: production_catalog
      gold_schema: system_gold
```

---

### Variable Substitution in Deployment Script

**File: `src/genie/deploy_genie_space.py`**

```python
def substitute_variables(data: dict, variables: dict) -> dict:
    """Replace template variables with actual values from databricks.yml."""
    json_str = json.dumps(data)
    
    # Standard substitutions
    json_str = json_str.replace("${catalog}", variables.get('catalog', ''))
    json_str = json_str.replace("${gold_schema}", variables.get('gold_schema', ''))
    json_str = json_str.replace("${feature_schema}", variables.get('feature_schema', ''))
    
    # Monitoring schema pattern
    monitoring_schema = f"{variables.get('gold_schema', '')}_monitoring"
    json_str = json_str.replace("${gold_schema}_monitoring", monitoring_schema)
    
    return json.loads(json_str)


def deploy_genie_space(space_name: str, genie_config: dict):
    """Deploy with variable substitution."""
    
    # Get variables from dbutils widgets (passed from Asset Bundle)
    variables = {
        'catalog': dbutils.widgets.get('catalog'),
        'gold_schema': dbutils.widgets.get('gold_schema'),
        'feature_schema': dbutils.widgets.get('feature_schema'),
    }
    
    # Substitute BEFORE API call
    substituted_config = substitute_variables(genie_config, variables)
    
    # Now deploy with actual paths
    api_response = requests.post(
        f"{host}/api/2.0/genie/spaces",
        json={
            "title": space_name,
            "serialized_space": json.dumps(substituted_config)
        }
    )
```

---

### Programmatic JSON Generation

**Script: `scripts/regenerate_all_genie_spaces.py`**

```python
#!/usr/bin/env python3
"""Regenerate ALL Genie Space JSON files from asset inventory."""

import json
import uuid
from pathlib import Path

INVENTORY_PATH = Path("src/genie/actual_assets_inventory.json")
GENIE_DIR = Path("src/genie")

def generate_id():
    return uuid.uuid4().hex

def regenerate_genie_space(space_name: str, inventory: dict):
    """Regenerate one Genie Space from inventory."""
    
    json_path = GENIE_DIR / f"{space_name}_genie_export.json"
    
    with open(json_path) as f:
        genie_data = json.load(f)
    
    mappings = inventory['genie_space_mappings'].get(space_name, {})
    
    # === UPDATE DATA SOURCES FROM INVENTORY ===
    
    # Tables (dimension, fact, ML, monitoring)
    genie_data['data_sources']['tables'] = [
        {"identifier": table_id}
        for table_id in mappings.get('tables', [])
    ]
    
    # Metric views
    genie_data['data_sources']['metric_views'] = [
        {"identifier": mv_id}
        for mv_id in mappings.get('metric_views', [])
    ]
    
    # TVFs (with ID generation and limit enforcement)
    tvfs = [
        {"id": generate_id(), "identifier": tvf_id}
        for tvf_id in mappings.get('sql_functions', [])
    ]
    
    # API LIMIT: Max 50 sql_functions
    if len(tvfs) > 50:
        print(f"  ⚠️ Truncating {space_name} TVFs: {len(tvfs)} → 50")
        tvfs = tvfs[:50]
    genie_data['instructions']['sql_functions'] = tvfs
    
    # === FIX JSON FORMAT ISSUES ===
    
    # Fix sample_questions: ensure question is array
    for sq in genie_data.get('config', {}).get('sample_questions', []):
        if isinstance(sq.get('question'), str):
            sq['question'] = [sq['question']]
        if 'id' not in sq or not sq['id']:
            sq['id'] = generate_id()
    
    # Fix benchmarks: ensure question is array
    for bq in genie_data.get('benchmarks', {}).get('questions', []):
        if isinstance(bq.get('question'), str):
            bq['question'] = [bq['question']]
    
    # API LIMIT: Max 50 benchmarks
    benchmarks = genie_data.get('benchmarks', {}).get('questions', [])
    if len(benchmarks) > 50:
        print(f"  ⚠️ Truncating {space_name} benchmarks: {len(benchmarks)} → 50")
        genie_data['benchmarks']['questions'] = benchmarks[:50]
    
    # Write back
    with open(json_path, 'w') as f:
        json.dump(genie_data, f, indent=2)
    
    print(f"✅ Regenerated {space_name}")
    return True


def main():
    with open(INVENTORY_PATH) as f:
        inventory = json.load(f)
    
    spaces = [
        "cost_intelligence",
        "job_health_monitor",
        "performance",
        "security_auditor",
        "data_quality_monitor",
        "unified_health_monitor"
    ]
    
    for space in spaces:
        regenerate_genie_space(space, inventory)
    
    print("\n✅ All Genie Spaces regenerated!")


if __name__ == "__main__":
    main()
```

---

### Spec File Synchronization

**Keep `.md` spec files aligned with JSON and inventory:**

```python
#!/usr/bin/env python3
"""Update spec files from inventory."""

def update_spec_data_assets(space_name: str, inventory: dict):
    """Update Data Assets section in spec .md file."""
    
    md_path = Path(f"src/genie/{space_name}_genie.md")
    mappings = inventory['genie_space_mappings'].get(space_name, {})
    
    # Extract short names
    mvs = [id.split('.')[-1] for id in mappings.get('metric_views', [])]
    tables = [id.split('.')[-1] for id in mappings.get('tables', [])]
    tvfs = [id.split('.')[-1] for id in mappings.get('sql_functions', [])]
    
    # Generate markdown
    mv_md = "### Metric Views\n| Metric View | Purpose | Key Measures |\n|---|---|---|\n"
    for mv in mvs:
        mv_md += f"| `{mv}` | TBD | TBD |\n"
    
    tables_md = "### Tables\n| Table | Purpose |\n|---|---|\n"
    for t in tables:
        tables_md += f"| `{t}` | TBD |\n"
    
    tvfs_md = "### Table-Valued Functions (TVFs)\n| TVF | Purpose |\n|---|---|\n"
    for tvf in tvfs:
        tvfs_md += f"| `{tvf}` | TBD |\n"
    
    # Update file with regex replacement...
```

---

### Complete Generation Workflow

```bash
# 1. Query Unity Catalog (manual SQL in Databricks notebook)
#    - Get all tables, views, functions
#    - Update actual_assets_inventory.json

# 2. Regenerate ALL JSON files
python scripts/regenerate_all_genie_spaces.py

# 3. Update ALL spec files
python scripts/update_spec_data_assets.py
python scripts/update_spec_descriptions.py

# 4. Verify alignment
python scripts/align_genie_spec_files.py

# 5. Validate JSON structure
python scripts/validate_against_reference.py

# 6. Deploy (variables substituted at runtime)
databricks bundle run -t dev genie_spaces_deployment_job
```

---

### API Limits Reference

| Resource | Limit | Enforcement |
|----------|-------|-------------|
| `instructions.sql_functions` | **Max 50** | Truncate in generation script |
| `benchmarks.questions` | **Max 50** | Truncate in generation script |
| `data_sources.tables` | No hard limit | Keep ~25-30 for performance |
| `data_sources.metric_views` | No hard limit | Keep ~5-10 per space |
| `serialized_space` size | ~1MB suggested | Monitor payload size |

---

### Error Recovery Patterns

#### Error: `TABLE_OR_VIEW_NOT_FOUND`

**Cause:** Table referenced in `data_sources` doesn't exist.

**Fix:**
1. Query Unity Catalog to verify table existence
2. Update `actual_assets_inventory.json` 
3. Regenerate JSON: `python scripts/regenerate_all_genie_spaces.py`

#### Error: `Exceeded maximum number (50) of certified answer inputs`

**Cause:** More than 50 TVFs in `sql_functions`.

**Fix:** Generation script enforces limit automatically. If manual edit, truncate to 50.

#### Error: `INTERNAL_ERROR: Failed to retrieve schema from unity catalog`

**Cause:** Could be column_configs OR non-existent tables.

**Fix:**
1. Remove `column_configs` from data_sources
2. Verify all tables exist via UC query
3. Regenerate from inventory

#### Error: Genie Space shows wrong tables in UI

**Cause:** Template variables not substituted.

**Fix:** Check `substitute_variables()` is called BEFORE API call.

---

## Version History

- **v3.0** (January 14, 2026) - Inventory-driven programmatic generation
  - **Achieved**: 100% deployment success with automated generation (6/6 Genie Spaces)
  - Added asset inventory schema and best practices
  - Added template variable system for cross-workspace deployment
  - Added variable substitution patterns for deployment script
  - Added programmatic JSON generation script template
  - Added spec file synchronization patterns
  - Added complete generation workflow (6-step process)
  - Added API limits reference table with enforcement patterns
  - Added error recovery patterns with specific fixes
  - **Critical Discovery**: Manual JSON editing caused 36+ non-existent table errors
  - **Critical Discovery**: Hardcoded paths break cross-workspace deployment
  - **Key Learning**: Inventory-first approach eliminates "table doesn't exist" errors
  - **Key Learning**: Template variables + runtime substitution = workspace portability
  - **Impact**: 
    - 0 non-existent table errors (vs 36+ in manual approach)
    - 0 API limit violations (enforced in generation)
    - 100% spec file alignment with JSON
    - Single command regeneration for all 6 Genie Spaces
  - Based on: Session 24 production deployment - complete inventory-driven workflow

- **v2.0** (January 13, 2026) - Production deployment patterns from Health Monitor project
  - **Achieved**: 100% deployment success (6/6 Genie Spaces) after format fixes
  - **Key Discovery**: `column_configs` triggers Unity Catalog validation that fails for complex spaces
  - Added exact format requirements from reference file (`context/genie/genie_space_export.json`)
  - Added 8 common production errors with Python fix scripts
  - Added field-level validation patterns (what's required, what's forbidden)
  - Added comprehensive deployment checklist (4-step validation workflow)
  - Created `scripts/validate_against_reference.py` for structural validation
  - **Critical Fixes Applied**:
    - `cost_intelligence`: Fixed sample_questions (strings → objects), metric_views (full_name → identifier)
    - `security_auditor`: Fixed sql_functions (added missing id field)
    - All 3 failing spaces: Removed column_configs (124 configs removed)
  - **Impact**: Deployment success rate improved from 33% (2/6) → 50% (3/6) → 100% (6/6)
  - **Deployment Journey**: 22 sessions, 200+ SQL fixes, 26 format corrections, 150 benchmark questions validated
  - **Validation Results**: 88.7% pass rate (133/150 queries) - 17 failures due to schema mismatches, not deployment issues
    - ✅ 3 spaces: Job Health (25/25), Performance (25/25), Cost Intelligence (25/25)
    - 🔧 3 spaces need fixes: Unified Health (21/25), Security Auditor (20/25), Data Quality (17/25)
    - Root cause: Benchmark questions reference non-existent columns/tables in Gold layer
    - **Next**: Session 23+ to fix schema mismatches and reach 150/150
  - Key learning: Reference-based validation is essential - compare against working examples, not just documentation
  - Key learning: Deployment success ≠ Query success - validate both structure AND schema
  
- **v1.0** (January 2026) - Initial rule based on API export/import analysis
  - Complete GenieSpaceExport schema documentation
  - TypeScript interface reference
  - Patterns from actual exported Genie Space
  - ID generation and serialization patterns
  - Deployment script template
